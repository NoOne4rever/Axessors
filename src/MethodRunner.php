<?php
/**
 * This file is a part of "Axessors" library.
 *
 * @author <NoOne4rever@gmail.com>
 * @license GPL
 */

namespace NoOne4rever\Axessors;

use NoOne4rever\Axessors\Exceptions\AxessorsError;
use NoOne4rever\Axessors\Exceptions\TypeError;

/**
 * Class MethodRunner.
 *
 * Runs a method generated by Axessors.
 *
 * @package NoOne4rever\Axessors
 */
class MethodRunner extends RunningSuit
{
    /** @var string method name */
    private $method;

    /**
     * MethodRunner constructor.
     *
     * @param int $mode running mode
     * @param PropertyData $data property data
     * @param string $class class
     * @param string $method method name
     * @param object|null $object object
     */
    public function __construct(int $mode, PropertyData $data, string $class, string $method, $object = null)
    {
        parent::__construct($mode, $data, $class, $object);
        $this->method = $method;
    }

    /**
     * Emulates execution of the method.
     *
     * @param array $args the arguments of the method called
     * @return mixed return value of the method called
     * @throws AxessorsError if conditions for executing an accessor did not pass
     * @throws AxessorsError if Axessors method not found
     */
    public function run(array $args)
    {
        $prefix = substr($this->method, 0, 3);
        if ($prefix == 'get') {
            $this->propertyData->reflection->setAccessible(true);
            $value = is_null($this->object) ? $this->propertyData->reflection->getValue() : $this->propertyData->reflection->getValue($this->object);
            $this->propertyData->reflection->setAccessible(false);
            return $this->executeAccessor(RunningSuit::OUTPUT_MODE, $value);
        } elseif ($prefix == 'set') {
            $value = $this->executeAccessor(RunningSuit::INPUT_MODE, $args[0]);
            $this->propertyData->reflection->setAccessible(true);
            is_null($this->object) ? $this->propertyData->reflection->setValue($value) : $this->propertyData->reflection->setValue($this->object,
                $value);
            $this->propertyData->reflection->setAccessible(false);
            return;
        } else {
            $this->method = str_replace(ucfirst($this->propertyData->getName()), 'PROPERTY', $this->method);
            return $this->executeAxessorsMethod($args);
        }
    }

    /**
     * Executes Axessors method.
     *
     * @param array $args method parameters
     * @return mixed result of function
     * @throws AxessorsError if requested method not found
     */
    private function executeAxessorsMethod(array $args)
    {
        $this->propertyData->reflection->setAccessible(true);
        $value = $this->propertyData->reflection->getValue($this->object);
        $this->checkType($this->propertyData->getTypeTree(), $value);
        foreach ($this->propertyData->getTypeTree() as $type => $subType) {
            $type = is_int($type) ? $subType : $type;
            $reflection = new \ReflectionClass($type);
            foreach ($reflection->getMethods() as $method) {
                if (!($method->isStatic() && $method->isPublic() && !$method->isAbstract())) {
                    continue;
                }
                if ($method->name == "m_in_$this->method") {
                    // add support for static properties
                    $this->propertyData->reflection->setValue($this->object,
                        call_user_func([$type, "m_in_$this->method"], $value, $args));
                    $this->propertyData->reflection->setAccessible(false);
                    return;
                } elseif ($method->name == "m_out_$this->method") {
                    $result = call_user_func([$type, "m_out_$this->method"], $value, $args);
                    $this->propertyData->reflection->setAccessible(false);
                    return $result;
                }
            }
        }
        throw new AxessorsError("method {$this->class}::{$this->method}() not found");
    }

    /**
     * Executes complex accessor.
     *
     * @param int $mode running mode
     * @param mixed $value field or argument value
     * @return mixed new value
     * @throws AxessorsError if conditions for accessor did not pass
     */
    private function executeAccessor(int $mode, $value)
    {
        $this->checkType($this->propertyData->getTypeTree(), $value);
        $conditionsSuit = new ConditionsSuit($mode, $this->propertyData, $this->class, $this->method, $this->object);
        if ($conditionsSuit->processConditions($value)) {
            $handlersSuit = new HandlersSuit($mode, $this->propertyData, $this->class, $this->object);
            $value = $handlersSuit->executeHandlers($value);
            return $value;
        } else {
            throw new AxessorsError("conditions for {$this->class}::{$this->method}() did not pass");
        }
    }

    /**
     * Checks if the type of new property's value is correct.
     *
     * @param array $typeTree all possible types
     * @param $var mixed new value of the property
     * @throws TypeError if the type of new property's value does not match the type defined in Axessors comment
     */
    private function checkType(array $typeTree, $var): void
    {
        foreach ($typeTree as $type => $subType) {
            if (is_int($type)) {
                if ($var instanceof $subType || ((new \ReflectionClass($subType))->hasMethod('is') && call_user_func([
                            $subType,
                            'is'
                        ], $var))) {
                    return;
                }
            } else {
                if (is_iterable($var) && ($var instanceof $type || ((new \ReflectionClass($type))->hasMethod('is') && call_user_func([
                                $type,
                                'is'
                            ], $var)))) {
                    foreach ($var as $subVar) {
                        $this->checkType($subType, $subVar);
                    }
                    return;
                }
            }
        }
        throw new TypeError("not a valid type of {$this->class}::\${$this->propertyData->getName()}");
    }
}